================================================================================
           NEO4J DATABASE OPERATIONS - ARCHITECTURE SUMMARY
================================================================================

PROJECT STRUCTURE:
==================

/ragforge/packages/
├── runtime/
│   ├── src/
│   │   ├── client/
│   │   │   └── neo4j-client.ts          [Neo4jClient class]
│   │   ├── query/
│   │   │   └── query-builder.ts         [QueryBuilder<T> class]
│   │   ├── vector/
│   │   │   └── vector-search.ts         [VectorSearch class]
│   │   ├── types/
│   │   │   ├── config.ts
│   │   │   ├── query.ts
│   │   │   ├── result.ts
│   │   │   └── index.ts
│   │   └── index.ts                     [createClient() factory]
│   └── example.ts                       [Usage examples]
│
└── core/
    ├── src/
    │   ├── schema/
    │   │   └── introspector.ts          [SchemaIntrospector class]
    │   └── types/
    │       ├── config.ts                [RagForgeConfig types]
    │       └── schema.ts                [Schema type definitions]

/src/lib/neo4j/
├── client.ts                            [Legacy helper functions]
└── index.ts

================================================================================

EXECUTION FLOW:
===============

Application Code
      |
      v
createClient(RuntimeConfig)  ← Initialize RAG client
      |
      +---> Neo4jClient      ← Manages Neo4j connection
      |        |
      |        ├---> driver creation (neo4j-driver)
      |        ├---> session management
      |        ├---> query execution
      |        └---> transaction handling
      |
      +---> QueryBuilder     ← Build complex queries
      |        |
      |        ├---> where()          [Filter conditions]
      |        ├---> semantic()       [Vector search]
      |        ├---> expand()         [Graph traversal]
      |        ├---> execute()        [Run query]
      |        └---> explain()        [Query plan]
      |
      +---> VectorSearch    ← Semantic search
             |
             ├---> generateEmbedding()  [Vertex AI]
             ├---> search()             [Vector index query]
             └---> mergeResults()       [Score combination]


================================================================================

CORE METHODS BY RESPONSIBILITY:
================================

1. CONNECTION & CLIENT SETUP
   ├─ Neo4jClient.constructor()         - Initialize driver
   ├─ Neo4jClient.verifyConnectivity()  - Health check
   └─ Neo4jClient.close()               - Cleanup

2. QUERY EXECUTION
   ├─ Neo4jClient.run()                 - Direct Cypher execution
   ├─ QueryBuilder.execute()            - Built query execution
   └─ Neo4jClient.explain()             - Query planning

3. SESSION MANAGEMENT
   ├─ Neo4jClient.transaction()         - Write transaction
   ├─ Neo4jClient.readTransaction()     - Read transaction
   └─ [Internal] driver.session()       - Session creation/cleanup

4. QUERY BUILDING
   ├─ QueryBuilder.where()              - Field filtering
   ├─ QueryBuilder.semantic()           - Semantic search
   ├─ QueryBuilder.expand()             - Relationship expansion
   ├─ [Private] buildCypher()           - Cypher generation
   └─ [Private] buildWhereConditions()  - WHERE clause building

5. SEMANTIC SEARCH
   ├─ VectorSearch.generateEmbedding()  - Text embedding
   ├─ VectorSearch.search()             - Vector index query
   ├─ Neo4jClient.vectorSearch()        - Direct vector query
   └─ [Private] mergeResults()          - Score merging

6. SCHEMA DISCOVERY
   ├─ SchemaIntrospector.introspect()   - Full schema analysis
   ├─ [Private] introspectNodes()       - Node label discovery
   ├─ [Private] introspectRelationships()  - Relationship discovery
   ├─ [Private] introspectIndexes()     - Index discovery
   └─ [Private] introspectVectorIndexes()  - Vector index discovery


================================================================================

DATA FLOW EXAMPLES:
===================

EXAMPLE 1: Simple Filter Query
-------------------------------
client.query('Scope')
  .where({ type: 'function' })
  .execute()
        |
        v
  [QueryBuilder]
        |
        +---> buildCypher()
        |       |
        |       v
        |     MATCH (n:`Scope`)
        |     WHERE n.type = $type
        |     RETURN n
        |
        +---> Neo4jClient.run(cypher, params)
        |       |
        |       v
        |     [Session created]
        |     [Query executed]
        |     [Results parsed]
        |     [Session closed]
        |
        v
  [SearchResult<T>[]]


EXAMPLE 2: Semantic + Filter Query
----------------------------------
client.query('Scope')
  .where({ type: 'function' })
  .semantic('auth handler', { vectorIndex: 'embeddings' })
  .execute()
        |
        v
  [QueryBuilder.execute()]
        |
        +---> Build filter query
        |     MATCH (n:`Scope`) WHERE n.type = $type RETURN n
        |
        +---> Execute filter query
        |     -> Get 5 initial results
        |
        +---> VectorSearch.search('auth handler')
        |     |
        |     +---> generateEmbedding('auth handler')
        |     |       [Call Vertex AI API]
        |     |       [Get 768-dim vector]
        |     |
        |     +---> Neo4jClient.vectorSearch(index, embedding)
        |           [Query Neo4j vector index]
        |           [Get scored results]
        |
        +---> mergeResults(filterResults, vectorResults)
        |     score = filter_score * 0.3 + vector_score * 0.7
        |
        v
  [SearchResult<T>[] with merged scores]


EXAMPLE 3: Transaction with Multiple Operations
-----------------------------------------------
neo4jClient.transaction(async (tx) => {
  await tx.run('CREATE (n:Node {id: $id})', {id: 1});
  await tx.run('MATCH (n:Node) SET n.updated = true');
  return await tx.run('MATCH (n) RETURN count(n)');
})
        |
        v
  [Neo4jClient.transaction()]
        |
        +---> Create session
        |
        +---> session.executeWrite(fn)
        |     |
        |     +---> Execute all queries in transaction block
        |     |
        |     +---> If all succeed: COMMIT
        |     |
        |     +---> If any fail: ROLLBACK
        |
        +---> Close session
        |
        v
  [Result of final query]


================================================================================

CRITICAL IMPLEMENTATION PATTERNS:
==================================

SESSION MANAGEMENT PATTERN (Critical):
--------------------------------------
const session = driver.session({ database: this.database });
try {
  return await session.run(cypher, params);
} finally {
  await session.close();  // ALWAYS cleanup
}

This pattern ensures:
- No connection leaks
- Proper resource cleanup
- Database routing


CYPHER GENERATION PATTERN:
--------------------------
1. Initialize: cypher = 'MATCH (n:...)'
2. Add conditions: cypher += '\nWHERE ...'
3. Add expansions: cypher += '\nOPTIONAL MATCH ...'
4. Add returns: cypher += '\nRETURN ...'
5. Bind parameters: params = { field_name: value }

All parameters are NAMED (not positional):
- $type, $name_contains, $startLine_gte


SCORE MERGING PATTERN:
----------------------
When combining filter + vector results:

  final_score = filter_score * 0.3 + vector_score * 0.7

This weights semantic relevance (0.7) higher than field matching (0.3)


TYPE INFERENCE PATTERN:
-----------------------
const jsType = typeof value;
if (jsType === 'string') return 'String';
if (jsType === 'number') return Number.isInteger(value) ? 'Integer' : 'Float';
if (Array.isArray(value)) return 'List';
if (value.constructor?.name === 'DateTime') return 'DateTime';
// ... etc


================================================================================

CONFIGURATION HIERARCHY:
========================

RuntimeConfig (Top Level)
├── neo4j: Neo4jConfig
│   ├── uri
│   ├── username
│   ├── password
│   ├── database
│   ├── maxConnectionPoolSize (default: 50)
│   └── connectionTimeout (default: 30000ms)
│
├── embeddings: EmbeddingsConfig (optional)
│   ├── provider: 'openai' | 'vertex' | 'custom'
│   ├── apiKey
│   ├── endpoint
│   ├── model
│   └── dimension
│
└── reranking: RerankingConfig (optional)
    └── strategies: RerankingStrategy[]


RagForgeConfig (Core Package)
├── name
├── version
├── neo4j: Neo4jConfig
├── entities: EntityConfig[]
│   └── entity
│       ├── name
│       ├── searchable_fields
│       ├── vector_indexes
│       │   ├── name
│       │   ├── field (embedding property)
│       │   ├── source_field (text property)
│       │   ├── dimension
│       │   └── similarity
│       └── relationships
│
├── reranking: RerankingConfig (optional)
├── mcp: McpConfig (optional)
└── generation: GenerationConfig (optional)


================================================================================

KEY PERFORMANCE CHARACTERISTICS:
=================================

Connection Pooling:
  - Max: 50 connections (configurable)
  - Timeout: 30 seconds (configurable)
  - Reused across queries

Session Lifecycle:
  - Created: Per operation
  - Closed: In finally block
  - No persistence across operations

Vector Search:
  - Embedding generation: Vertex AI API call
  - Index query: Direct Neo4j query
  - Result merging: In-memory scoring
  - Weight: 70% vector, 30% filter

Query Execution:
  - Filter queries: Direct Cypher
  - Semantic-only: Vector search first, then expand
  - Combined: Cypher + vector merge
  - Plan analysis: Via EXPLAIN prefix


================================================================================

RESULT STRUCTURE:
=================

SearchResult<T>
├── entity: T                             [Matched entity]
├── score: number                         [0-1 relevance]
├── scoreBreakdown: {
│   ├── semantic?: number                 [Vector search score]
│   ├── topology?: number                 [Graph structure score]
│   └── custom?: Record<string, number>   [Custom scores]
│}
└── context?: {
    ├── related?: RelatedEntity[]         [Expanded relationships]
    │   ├── entity: any
    │   ├── relationshipType: string
    │   ├── direction: 'outgoing' | 'incoming'
    │   └── distance: number
    ├── snippet?: string                  [Match context]
    └── distance?: number                 [Graph distance]
}


QueryPlan
├── cypher: string
├── params: Record<string, any>
├── estimatedRows?: number                [EXPLAIN metadata]
├── indexesUsed?: string[]                [Extracted from plan]
└── executionSteps?: string[]             [Execution operators]


GraphSchema
├── nodes: NodeSchema[]                   [All node labels]
├── relationships: RelationshipSchema[]   [All relationship types]
├── indexes: IndexSchema[]                [BTREE, FULLTEXT indexes]
├── constraints: ConstraintSchema[]       [UNIQUE, EXISTS, NODE_KEY]
└── vectorIndexes: VectorIndexSchema[]    [Vector indexes]


================================================================================

IMPORTANT NOTES:
================

1. VectorSearch requires Google Cloud credentials
   - Uses Vertex AI embedding API
   - Model: text-embedding-004 (768 dimensions)
   - Requires authentication setup

2. All string parameters are safely escaped
   - Entity names use backticks for reserved words
   - Parameters use named placeholders ($name)
   - No SQL injection risk

3. Type inference is conservative
   - All properties marked nullable by default
   - Sample-based inference (up to 100 nodes)
   - Handles Neo4j-specific types

4. Transaction support
   - Write transactions: session.executeWrite()
   - Read transactions: session.executeRead()
   - Automatic retry on transient failures

5. Relationship expansion is expensive
   - Each expansion adds OPTIONAL MATCH clause
   - Deep traversals multiply complexity
   - Use depth limits judiciously

6. Score merging is deterministic
   - Vector: 70%, Filter: 30%
   - UUID-based entity matching
   - Missing matches scored lower

================================================================================
