/**
 * TypeScript Type Generator
 *
 * Generates TypeScript types from Neo4j schema
 */

import { GraphSchema, NodeSchema, PropertySchema, Neo4jType } from '../types/schema.js';
import { RagForgeConfig, EntityConfig } from '../types/config.js';

export class TypeGenerator {
  /**
   * Generate TypeScript type definitions from schema and config
   */
  static generate(schema: GraphSchema, config: RagForgeConfig): string {
    const lines: string[] = [];

    // Header
    lines.push('/**');
    lines.push(` * Generated types for ${config.name}`);
    lines.push(' * DO NOT EDIT - Generated by RagForge');
    lines.push(' */');
    lines.push('');

    // Generate types for each configured entity
    for (const entity of config.entities) {
      const nodeSchema = schema.nodes.find(n => n.label === entity.name);
      if (!nodeSchema) continue;

      lines.push(...this.generateEntityType(entity, nodeSchema));
      lines.push('');
      lines.push(...this.generateFilterType(entity, nodeSchema));
      lines.push('');
      lines.push(...this.generateCreateType(entity, nodeSchema));
      lines.push('');
      lines.push(...this.generateUpdateType(entity, nodeSchema));
      lines.push('');
    }

    // Generate search result type
    lines.push(...this.generateSearchResultType());
    lines.push('');

    // Generate query builder interface
    lines.push(...this.generateQueryBuilderInterface(config));

    return lines.join('\n');
  }

  private static generateEntityType(entity: EntityConfig, node: NodeSchema): string[] {
    const lines: string[] = [];

    lines.push(`export interface ${entity.name} {`);

    // Add all properties from config
    for (const field of entity.searchable_fields) {
      const property = node.properties.find(p => p.name === field.name);
      const tsType = this.mapToTypeScript(field.type);
      const optional = property?.nullable ? '?' : '';

      if (field.description) {
        lines.push(`  /** ${field.description} */`);
      }
      lines.push(`  ${field.name}${optional}: ${tsType};`);
    }

    // Add vector embedding if configured
    if (entity.vector_index) {
      lines.push(`  /** Vector embedding for semantic search */`);
      lines.push(`  embedding?: number[];`);
    }

    // Add relationship counts
    if (entity.relationships) {
      for (const rel of entity.relationships) {
        if (rel.direction === 'outgoing' || rel.direction === 'both') {
          lines.push(`  /** Count of ${rel.type} relationships */`);
          lines.push(`  ${this.camelCase(rel.type)}Count?: number;`);
        }
      }
    }

    lines.push('}');

    return lines;
  }

  private static generateFilterType(entity: EntityConfig, node: NodeSchema): string[] {
    const lines: string[] = [];

    lines.push(`export interface ${entity.name}Filter {`);

    for (const field of entity.searchable_fields) {
      const tsType = this.mapToTypeScript(field.type);

      // String fields get advanced operators
      if (field.type === 'string') {
        lines.push(`  ${field.name}?: ${tsType} | {`);
        lines.push(`    equals?: ${tsType};`);
        lines.push(`    contains?: ${tsType};`);
        lines.push(`    startsWith?: ${tsType};`);
        lines.push(`    endsWith?: ${tsType};`);
        lines.push(`    in?: ${tsType}[];`);
        lines.push(`  };`);
      }
      // Number fields get range operators
      else if (field.type === 'number') {
        lines.push(`  ${field.name}?: ${tsType} | {`);
        lines.push(`    equals?: ${tsType};`);
        lines.push(`    gt?: ${tsType};`);
        lines.push(`    gte?: ${tsType};`);
        lines.push(`    lt?: ${tsType};`);
        lines.push(`    lte?: ${tsType};`);
        lines.push(`    in?: ${tsType}[];`);
        lines.push(`  };`);
      }
      // Enum fields get in operator
      else if (field.type === 'enum') {
        const enumType = field.values?.map(v => `'${v}'`).join(' | ') || 'string';
        lines.push(`  ${field.name}?: ${enumType} | {`);
        lines.push(`    in?: (${enumType})[];`);
        lines.push(`  };`);
      }
      // Boolean and others are simple
      else {
        lines.push(`  ${field.name}?: ${tsType};`);
      }
    }

    lines.push('}');

    return lines;
  }

  private static generateSearchResultType(): string[] {
    return [
      'export interface SearchResult<T> {',
      '  /** The entity that matched */',
      '  entity: T;',
      '  ',
      '  /** Overall relevance score (0-1) */',
      '  score: number;',
      '  ',
      '  /** Score breakdown by strategy */',
      '  scoreBreakdown?: {',
      '    semantic?: number;',
      '    topology?: number;',
      '    custom?: Record<string, number>;',
      '  };',
      '  ',
      '  /** Additional context */',
      '  context?: {',
      '    /** Related entities (if expand was used) */',
      '    related?: any[];',
      '    ',
      '    /** Text snippet highlighting match */',
      '    snippet?: string;',
      '  };',
      '}'
    ];
  }

  private static generateQueryBuilderInterface(config: RagForgeConfig): string[] {
    const lines: string[] = [];

    lines.push('export interface QueryBuilder<T> {');
    lines.push('  /** Filter by field values */');
    lines.push('  where(filter: Partial<T>): QueryBuilder<T>;');
    lines.push('  ');
    lines.push('  /** Semantic search by text */');
    lines.push('  semantic(query: string, options?: { topK?: number }): QueryBuilder<T>;');
    lines.push('  ');
    lines.push('  /** Expand to related entities via relationships */');
    lines.push('  expand(relType: string, options?: { depth?: number }): QueryBuilder<T>;');
    lines.push('  ');
    lines.push('  /** Apply reranking strategy */');
    lines.push('  rerank(strategy: RerankingStrategy): QueryBuilder<T>;');
    lines.push('  ');
    lines.push('  /** Limit number of results */');
    lines.push('  limit(n: number): QueryBuilder<T>;');
    lines.push('  ');
    lines.push('  /** Skip first n results */');
    lines.push('  offset(n: number): QueryBuilder<T>;');
    lines.push('  ');
    lines.push('  /** Execute query and return results */');
    lines.push('  execute(): Promise<SearchResult<T>[]>;');
    lines.push('  ');
    lines.push('  /** Explain query plan (for debugging) */');
    lines.push('  explain(): Promise<QueryPlan>;');
    lines.push('}');
    lines.push('');

    // Reranking strategy type
    lines.push('export type RerankingStrategy =');
    if (config.reranking?.strategies) {
      const strategies = config.reranking.strategies.map(s => `  | '${s.name}'`);
      lines.push(...strategies);
    } else {
      lines.push("  | 'semantic'");
    }
    lines.push('  | { strategy: string; weights?: Record<string, number> };');

    return lines;
  }

  /**
   * Generate Create type for entity
   * All fields are optional except the unique field
   */
  private static generateCreateType(entity: EntityConfig, node: NodeSchema): string[] {
    const lines: string[] = [];
    const uniqueField = entity.unique_field || 'uuid';

    lines.push(`/**`);
    lines.push(` * Input type for creating ${entity.name} entities`);
    lines.push(` * All fields are optional except '${uniqueField}' which is required for uniqueness`);
    lines.push(` */`);
    lines.push(`export interface ${entity.name}Create {`);

    // Add all properties from config
    for (const field of entity.searchable_fields) {
      const property = node.properties.find(p => p.name === field.name);
      const tsType = this.mapToTypeScript(field.type);
      // Unique field is required, all others are optional
      const optional = field.name === uniqueField ? '' : '?';

      if (field.description) {
        lines.push(`  /** ${field.description} */`);
      }
      lines.push(`  ${field.name}${optional}: ${tsType};`);
    }

    lines.push('}');

    return lines;
  }

  /**
   * Generate Update type for entity
   * All fields are optional (partial update)
   * Unique field is excluded (cannot be updated)
   */
  private static generateUpdateType(entity: EntityConfig, node: NodeSchema): string[] {
    const lines: string[] = [];
    const uniqueField = entity.unique_field || 'uuid';

    lines.push(`/**`);
    lines.push(` * Input type for updating ${entity.name} entities`);
    lines.push(` * All fields are optional for partial updates`);
    lines.push(` * The unique field '${uniqueField}' cannot be updated`);
    lines.push(` */`);
    lines.push(`export interface ${entity.name}Update {`);

    // Add all properties except unique field
    for (const field of entity.searchable_fields) {
      // Skip unique field (cannot be updated)
      if (field.name === uniqueField) continue;

      const property = node.properties.find(p => p.name === field.name);
      const tsType = this.mapToTypeScript(field.type);

      if (field.description) {
        lines.push(`  /** ${field.description} */`);
      }
      lines.push(`  ${field.name}?: ${tsType};`);
    }

    lines.push('}');

    return lines;
  }

  private static mapToTypeScript(fieldType: string): string {
    const typeMap: Record<string, string> = {
      'string': 'string',
      'number': 'number',
      'boolean': 'boolean',
      'datetime': 'Date',
      'enum': 'string',
      'array<string>': 'string[]',
      'array<number>': 'number[]'
    };

    return typeMap[fieldType] || 'any';
  }

  private static camelCase(str: string): string {
    return str
      .toLowerCase()
      .replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
  }
}
