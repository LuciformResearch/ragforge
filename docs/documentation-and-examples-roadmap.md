# RagForge Documentation & Examples Roadmap

**Goal**: Improve RagForge documentation and provide comprehensive, high-quality examples that showcase different use cases and workflows.

## Current State

### Documentation
- ✅ Root README exists but slightly outdated (still shows old `introspect` workflow)
- ✅ CLI README is detailed and up-to-date with recent improvements
- ✅ `ragforge -h` shows simplified workflow with `init` as primary command
- ⚠️ Missing: comprehensive guides for different workflows (YAML-first vs DB-first)

### Examples
- ✅ `ragforge-sample/` - Complete bookstore example with docker-compose, seed data, .env
- ✅ `examples/code-rag/` - Has ragforge.config.yaml but no complete setup
- ❌ `examples/doc-rag/` - Empty directory
- ❌ `examples/ecommerce-rag/` - Empty directory
- ⚠️ Many test/debug files in `examples/` that are not user-facing examples

### Features
- ✅ Schema introspection from Neo4j
- ✅ Type-safe query generation (READ operations)
- ✅ Semantic search with vector indexes
- ✅ LLM-powered auto-detection of fields and project metadata
- ❌ **Schema mutations** (add entities/fields/relationships)
- ❌ **CRUD operations** (CREATE, UPDATE, DELETE)
- ❌ **Schema evolution tools** (migrations, incremental regeneration)

---

## Phase 1: Documentation Updates

### 1.1 Update Root README (`ragforge/README.md`)

**Priority**: High

**Tasks**:
- [ ] Update Quick Start to highlight `ragforge init` as the primary command
- [ ] Add clear .env documentation upfront (before quick start)
- [ ] Show both workflows clearly:
  - **DB-first** (recommended): `ragforge init` → introspect + generate in one step
  - **YAML-first**: Manually create config → `ragforge generate`
- [ ] Update code examples to reflect new simplified CLI
- [ ] Add section: "Three Ways to Start with RagForge"
  1. From existing Neo4j DB (auto-detect with LLM)
  2. From existing Neo4j DB (manual config)
  3. From handwritten YAML config (future: generate empty DB)
- [ ] Link to comprehensive examples
- [ ] Update workflow diagrams/explanations

**Acceptance Criteria**:
- New users understand the recommended `ragforge init --auto-detect-fields` workflow immediately
- Different starting points are clearly documented (DB vs YAML)
- Examples link to actual working sample projects

---

### 1.2 Update CLI README (`ragforge/packages/cli/README.md`)

**Priority**: Medium

**Tasks**:
- [ ] Emphasize `ragforge init --auto-detect-fields` as the easiest starting point
- [ ] Add "Complete Workflows" section showing end-to-end examples:
  - From scratch with existing DB
  - From docker-compose + seed data
  - From existing YAML config
- [ ] Document the LLM auto-detection features:
  - Project name detection
  - Project description generation
  - Field mapping detection
  - What data it analyzes
- [ ] Add troubleshooting section:
  - Common errors
  - GEMINI_API_KEY requirements
  - Neo4j connection issues
- [ ] Link to working examples with "Try it yourself" sections

**Acceptance Criteria**:
- Users know when to use `--auto-detect-fields`
- Clear guidance on .env setup vs CLI args
- Links to all example projects

---

### 1.3 Enhance `ragforge -h` Output (Optional)

**Priority**: Low (already improved recently)

**Tasks**:
- [ ] Review current help output
- [ ] Add examples section at the bottom
- [ ] Consider adding ASCII diagram showing workflow

**Current State**: Already shows clear quick start with .env documentation. May not need changes.

---

## Phase 2: Example Projects Restructuring

### 2.1 Organize Examples Directory

**Priority**: High

**Current State**: `/ragforge/examples/` is cluttered with test files

**Proposed Structure**:
```
examples/
├── README.md                    # NEW: Index of all examples
├── 01-bookstore/               # RENAME from ragforge-sample
│   ├── README.md               # Complete walkthrough
│   ├── docker-compose.yml
│   ├── .env.example
│   ├── seed-data/
│   │   └── bookstore-seed.cypher
│   └── [generated by ragforge init]
│
├── 02-code-search/             # ENHANCE existing code-rag
│   ├── README.md               # Complete walkthrough
│   ├── ragforge.config.yaml    # Manual YAML config
│   ├── docker-compose.yml      # NEW
│   ├── .env.example            # NEW
│   ├── seed-data/              # NEW
│   │   └── codebase-seed.cypher
│   └── [generated by ragforge generate]
│
├── 03-documentation/           # NEW (doc-rag)
│   ├── README.md
│   ├── ragforge.config.yaml
│   ├── docker-compose.yml
│   ├── .env.example
│   └── seed-data/
│       └── docs-seed.cypher
│
└── _archive/                   # MOVE test/debug files here
    ├── test-*.ts
    ├── check-*.ts
    └── ...
```

**Tasks**:
- [ ] Create `examples/README.md` as index
- [ ] Move `ragforge-sample/` → `examples/01-bookstore/`
- [ ] Enhance `examples/code-rag/` → `examples/02-code-search/`
- [ ] Create `examples/03-documentation/`
- [ ] Move all test/debug files to `examples/_archive/`
- [ ] Update all internal links

---

### 2.2 Example 01: Bookstore (Complete End-to-End)

**Priority**: High

**Source**: Current `ragforge-sample/`

**Workflow Demonstrated**:
- Start from scratch with Docker
- Seed database with sample data
- Use `ragforge init --auto-detect-fields` to auto-generate everything

**Tasks**:
- [ ] Move to `examples/01-bookstore/`
- [ ] Enhance README with:
  - "What You'll Learn" section
  - Complete step-by-step tutorial
  - Expected output at each step
  - Troubleshooting tips
- [ ] Add `.env.example` (rename current `.env`)
- [ ] Add screenshots/output examples
- [ ] Document generated project structure
- [ ] Add section on running the examples

**Files Included**:
```
01-bookstore/
├── README.md              # Complete tutorial
├── docker-compose.yml     # Neo4j setup
├── .env.example           # Connection template
├── seed-data/
│   └── bookstore-seed.cypher
└── book-catalog/         # Generated by ragforge init
    ├── ragforge.config.yaml
    ├── client.ts
    ├── examples/
    └── ...
```

**README Sections**:
1. Overview & Learning Objectives
2. Prerequisites
3. Step 1: Start Neo4j with Docker
4. Step 2: Seed the Database
5. Step 3: Generate RAG Framework with Auto-Detection
6. Step 4: Explore Generated Project
7. Step 5: Run Examples
8. Step 6: Customize and Iterate
9. Cleanup
10. Next Steps

---

### 2.3 Example 02: Code Search (YAML-First Workflow)

**Priority**: High

**Source**: Current `examples/code-rag/`

**Workflow Demonstrated**:
- Start with handwritten YAML config
- Create database schema that matches the config (future)
- Generate framework from YAML
- Show manual configuration and customization

**Tasks**:
- [ ] Rename to `examples/02-code-search/`
- [ ] Create `docker-compose.yml` for Neo4j
- [ ] Create `.env.example`
- [ ] Create `seed-data/codebase-seed.cypher` with sample code graph
- [ ] Enhance `ragforge.config.yaml` with comments explaining each field
- [ ] Write comprehensive README showing YAML-first workflow
- [ ] Document manual field selection process
- [ ] Show how to iterate on the config

**Files Included**:
```
02-code-search/
├── README.md                 # YAML-first tutorial
├── ragforge.config.yaml      # Well-documented manual config
├── docker-compose.yml        # Neo4j setup
├── .env.example
├── seed-data/
│   └── codebase-seed.cypher  # Sample code graph
└── generated/               # Generated by ragforge generate
    ├── client.ts
    └── ...
```

**README Sections**:
1. Overview (YAML-First Approach)
2. When to Use This Approach
3. Step 1: Review the Config
4. Step 2: Start Neo4j
5. Step 3: Seed with Sample Code Graph
6. Step 4: Generate Framework
7. Understanding the Generated Code
8. Customizing Your Config
9. Tips for Creating Your Own YAML Configs

---

### 2.4 Example 03: Documentation Search (Minimal Example)

**Priority**: Medium

**Source**: New example for `examples/doc-rag/`

**Workflow Demonstrated**:
- Simpler domain (just documents)
- Focus on semantic search without complex relationships
- Good starting point for newcomers

**Tasks**:
- [ ] Rename to `examples/03-documentation/`
- [ ] Create `ragforge.config.yaml` for documents domain
- [ ] Create `docker-compose.yml`
- [ ] Create `.env.example`
- [ ] Create `seed-data/docs-seed.cypher` with documentation nodes
- [ ] Write README focused on simplicity
- [ ] Demonstrate single entity with vector search

**Files Included**:
```
03-documentation/
├── README.md
├── ragforge.config.yaml      # Simple config (just Document entity)
├── docker-compose.yml
├── .env.example
├── seed-data/
│   └── docs-seed.cypher
└── generated/
```

**Entity Schema**:
```yaml
name: documentation-search
entities:
  - name: Document
    searchable_fields:
      - { name: title, type: string }
      - { name: category, type: string }
      - { name: tags, type: string[] }
    vector_indexes:
      - name: documentContentEmbeddings
        field: embedding_content
        source_field: content
        model: gemini-embedding-001
        dimension: 768
    relationships:
      - type: LINKS_TO
        direction: outgoing
        target: Document
```

**README Focus**:
- Minimal, beginner-friendly
- Single entity example
- Semantic search basics
- Simple relationship traversal

---

### 2.5 Create Examples Index README

**Priority**: High

**File**: `examples/README.md`

**Content**:
- Overview of all examples
- Comparison table (complexity, use case, workflow type)
- Which example to start with based on user needs
- Prerequisites for all examples

**Comparison Table**:

| Example | Use Case | Complexity | Workflow | Best For |
|---------|----------|------------|----------|----------|
| **01-bookstore** | E-commerce graph | Beginner | DB-first (auto-detect) | Learning basics, seeing auto-detection |
| **02-code-search** | Code analysis | Advanced | YAML-first (manual) | Custom configs, complex domains |
| **03-documentation** | Doc search | Beginner | YAML-first (simple) | Simple semantic search, minimal setup |

---

## Phase 3: Advanced Features & Documentation

### 3.1 Feature: Generate Empty Database from YAML

**Priority**: Medium (future feature)

**Goal**: Allow users to start from a YAML config and generate an empty Neo4j schema

**Tasks**:
- [ ] Design `ragforge schema:create` command
- [ ] Implement Neo4j constraint/index creation from YAML
- [ ] Generate Cypher DDL from entity definitions
- [ ] Support for:
  - Node labels
  - Relationship types
  - Property constraints
  - Unique constraints
  - Vector indexes
- [ ] Create documentation
- [ ] Add example showing this workflow

**Command Design**:
```bash
ragforge schema:create \
  --config ./ragforge.config.yaml \
  --uri bolt://localhost:7687 \
  --username neo4j \
  --password password
```

**Generated**:
- Creates all node labels
- Creates all relationship types
- Creates unique constraints
- Creates vector indexes
- Does NOT create data (just schema)

---

### 3.2 Feature: Generate Seed Data Templates

**Priority**: Low (nice to have)

**Goal**: Generate template .cypher files for seeding data based on config

**Tasks**:
- [ ] Design `ragforge seed:template` command
- [ ] Generate Cypher CREATE statements with placeholders
- [ ] Include comments explaining each field
- [ ] Support for all entity types and relationships in config

**Example Output** (`seed-template.cypher`):
```cypher
// Create Author nodes
CREATE (a1:Author {
  uuid: 'author-1',           // Required: unique identifier
  name: 'John Smith',         // Required: display name
  bio: 'Author biography...'  // Optional: additional context
});

// Create Book nodes
CREATE (b1:Book {
  uuid: 'book-1',
  title: 'Sample Book',
  isbn: '978-0-123456-78-9',
  // ... more fields
});

// Create relationships
MATCH (b:Book {uuid: 'book-1'}), (a:Author {uuid: 'author-1'})
CREATE (b)-[:WRITTEN_BY]->(a);
```

---

### 3.3 Enhanced Documentation for Advanced Users

**Priority**: Medium

**New Docs**:
- [ ] `docs/yaml-config-reference.md` - Complete YAML schema documentation
- [ ] `docs/customizing-queries.md` - Extending generated queries
- [ ] `docs/reranking-strategies.md` - Deep dive on reranking
- [ ] `docs/vector-indexes.md` - Embedding configuration guide
- [ ] `docs/llm-auto-detection.md` - How auto-detection works internally
- [ ] `docs/troubleshooting.md` - Common issues and solutions

---

## Phase 4: Interactive Improvements

### 4.1 Improve CLI Help Messages

**Priority**: Low

**Tasks**:
- [ ] Add colors to help output (using chalk)
- [ ] Show ASCII workflow diagram in help
- [ ] Add "Did you mean?" suggestions for typos
- [ ] Context-aware help (detect .env, show relevant commands)

### 4.2 Add Interactive Mode (Optional)

**Priority**: Low (future consideration)

**Concept**: `ragforge init --interactive`

**Features**:
- Prompt for Neo4j connection
- Test connection before proceeding
- Ask if user wants auto-detection
- Show progress with spinners
- Preview config before generation
- Option to edit config in editor before generating

---

## Phase 6: Schema Mutation & CRUD Operations

### 6.1 Add Schema Modification Commands

**Priority**: High (Core Feature)

**Goal**: Enable users to evolve their Neo4j schema and automatically update generated code

**Current State**: RagForge is read-only (introspection + queries). No support for schema mutations.

**Concept**: Allow incremental schema evolution with automatic code regeneration

**New Commands**:

#### `ragforge schema:add-entity`
Add a new entity type to the database and config

```bash
ragforge schema:add-entity \
  --name Review \
  --config ./ragforge.config.yaml \
  --fields "rating:number,comment:string,created_at:date" \
  --unique-field reviewId \
  --display-name-field comment
```

**Behavior**:
- Updates `ragforge.config.yaml` with new entity
- Generates Cypher constraint queries
- Applies constraints to Neo4j
- **Automatically regenerates** query builders for the new entity
- Updates TypeScript types
- Generates example queries for the new entity

#### `ragforge schema:add-field`
Add a field to an existing entity

```bash
ragforge schema:add-field \
  --entity Book \
  --name publisher \
  --type string \
  --config ./ragforge.config.yaml \
  [--searchable]  # Add to searchable_fields
  [--indexed]     # Create database index
```

**Behavior**:
- Updates entity definition in config YAML
- Adds field to TypeScript types
- If `--searchable`: adds filter method to query builder (e.g., `wherePublisher()`)
- If `--indexed`: generates CREATE INDEX cypher query
- Regenerates affected code files

#### `ragforge schema:add-relationship`
Add a new relationship type

```bash
ragforge schema:add-relationship \
  --from Book \
  --to Review \
  --type HAS_REVIEW \
  --direction outgoing \
  --config ./ragforge.config.yaml \
  [--properties "verified:boolean,flagged:boolean"]
```

**Behavior**:
- Updates both entity definitions with new relationship
- Generates relationship traversal methods:
  - `book().whereHasReview()` - filter by relationship existence
  - `book().expandHasReview()` - traverse to related Reviews
- Updates TypeScript types with relationship interfaces
- Adds relationship to generated documentation

#### `ragforge schema:add-vector-index`
Add embedding support to an entity field

```bash
ragforge schema:add-vector-index \
  --entity Review \
  --source-field comment \
  --name reviewCommentEmbeddings \
  --config ./ragforge.config.yaml \
  [--model gemini-embedding-001] \
  [--dimension 768]
```

**Behavior**:
- Adds vector index config to entity
- Generates semantic search method (e.g., `semanticSearchByComment()`)
- Updates embedding scripts to include new index
- Generates Cypher for creating vector index in Neo4j
- Optionally runs embedding generation for existing data

---

### 6.2 Generate CRUD Operations

**Priority**: High

**Goal**: Auto-generate type-safe mutations (CREATE, UPDATE, DELETE) for entities

**Command**: `ragforge generate:mutations`

```bash
ragforge generate:mutations \
  --config ./ragforge.config.yaml \
  --out ./generated \
  [--entities Book,Author]  # Optional: limit to specific entities
```

**Generated APIs**:

```typescript
// Create operations
const newBook = await rag.book().create({
  uuid: 'book-123',
  title: 'New Book',
  isbn: '978-...',
  pageCount: 320
});

// Create with relationships
const bookWithAuthor = await rag.book().create({
  uuid: 'book-456',
  title: 'Another Book',
  relationships: {
    writtenBy: ['author-uuid-1']  // Connect to existing author
  }
});

// Update operations
await rag.book().update('book-123', {
  pageCount: 325,
  title: 'Updated Title'
});

// Delete operations
await rag.book().delete('book-123');

// Batch operations
await rag.book().createBatch([
  { uuid: 'b1', title: 'Book 1' },
  { uuid: 'b2', title: 'Book 2' }
]);

// Create relationship
await rag.book().addRelationship('book-123', {
  type: 'HAS_REVIEW',
  target: 'review-456',
  properties: { verified: true }
});

// Delete relationship
await rag.book().removeRelationship('book-123', {
  type: 'HAS_REVIEW',
  target: 'review-456'
});
```

**Generated Files**:
- `mutations/book.ts` - CRUD operations for Book entity
- `mutations/author.ts` - CRUD operations for Author entity
- `mutations/index.ts` - Aggregate exports
- Updates `client.ts` with mutation methods

**Features**:
- Type-safe mutations with full autocomplete
- Validation against schema (required fields, types)
- Transaction support for multi-node operations
- Relationship management (create, update, delete)
- Batch operations for performance
- Cascading deletes (configurable)
- Optimistic concurrency control

---

### 6.3 Intelligent Regeneration

**Priority**: Medium

**Goal**: Only regenerate affected code when schema changes

**Feature**: Smart diff and partial regeneration

**Scenarios**:

1. **Add field** → Only regenerate:
   - Entity types
   - Query builder for that entity
   - Documentation for that entity

2. **Add entity** → Generate:
   - New query builder file
   - New types
   - Update main client
   - Generate examples for new entity

3. **Add relationship** → Regenerate:
   - Both entity types involved
   - Query builders for both entities
   - Relationship types

4. **Add vector index** → Regenerate:
   - Entity query builder (add semantic search method)
   - Embedding scripts
   - Update load-config

**Command Option**: `--incremental`

```bash
ragforge generate \
  --config ./ragforge.config.yaml \
  --out ./generated \
  --incremental  # Only regenerate changed files
```

**Implementation**:
- Track file hashes/timestamps
- Compare previous config YAML with current
- Detect additions/modifications/deletions
- Regenerate only affected files
- Preserve user customizations in `custom/` directory

---

### 6.4 Schema Evolution Workflow

**Priority**: Medium

**Goal**: Document best practices for evolving schemas over time

**Workflow Example**:

```bash
# 1. Add a new entity
ragforge schema:add-entity \
  --name Review \
  --config ./ragforge.config.yaml \
  --fields "rating:number,comment:string"

# 2. Add relationship to existing entity
ragforge schema:add-relationship \
  --from Book \
  --to Review \
  --type HAS_REVIEW \
  --config ./ragforge.config.yaml

# 3. Add vector index for semantic search
ragforge schema:add-vector-index \
  --entity Review \
  --source-field comment \
  --config ./ragforge.config.yaml

# 4. Regenerate code (automatic if --auto-regenerate flag)
ragforge generate \
  --config ./ragforge.config.yaml \
  --out ./generated \
  --incremental

# 5. Create vector indexes in Neo4j
npm run embeddings:index

# 6. Generate embeddings for new field
npm run embeddings:generate
```

**Documentation**:
- Create `docs/schema-evolution.md`
- Best practices for adding entities/fields
- Migration strategies for existing data
- Handling breaking changes
- Versioning schemas

---

### 6.5 Migration Management

**Priority**: Low (Future Enhancement)

**Goal**: Track and apply schema migrations like a traditional ORM

**Concept**: `ragforge migrations`

```bash
# Generate a migration from config changes
ragforge migration:create "add-review-entity"

# Creates: migrations/20250106_add-review-entity.ts
# Contains:
# - Cypher queries to modify schema
# - Code generation commands
# - Rollback procedures

# Apply pending migrations
ragforge migration:up

# Rollback last migration
ragforge migration:down
```

**Migration File Structure**:
```typescript
export default {
  name: 'add-review-entity',
  timestamp: 20250106123045,

  async up(driver: Driver) {
    // Create constraints
    await driver.executeWrite(`
      CREATE CONSTRAINT review_uuid IF NOT EXISTS
      FOR (r:Review) REQUIRE r.uuid IS UNIQUE
    `);

    // Update config
    // Regenerate code
  },

  async down(driver: Driver) {
    // Rollback changes
    await driver.executeWrite(`
      DROP CONSTRAINT review_uuid IF EXISTS
    `);
  }
};
```

**Features**:
- Track applied migrations in Neo4j
- Idempotent migrations
- Dry-run mode
- Automatic backup before migrations
- Rollback support

---

### 6.6 Update Examples with Mutations

**Priority**: Medium

**Tasks**:
- [ ] Add mutation examples to generated projects
- [ ] Create `examples/04-mutations.ts` in each example project
- [ ] Document CRUD workflows
- [ ] Show relationship management
- [ ] Demonstrate batch operations

**Example** (`examples/04-create-and-link.ts`):
```typescript
import { createRagClient } from './client.js';

const rag = createRagClient({
  neo4j: { /* ... */ }
});

// Create a new book
const book = await rag.book().create({
  uuid: 'new-book-123',
  title: 'The New Adventure',
  isbn: '978-1-234567-89-0',
  pageCount: 450
});

console.log('Created book:', book.title);

// Link it to an existing author
await rag.book().addRelationship(book.uuid, {
  type: 'WRITTEN_BY',
  target: 'author-uuid-1'
});

console.log('Linked book to author');

// Query it back
const results = await rag
  .book()
  .whereTitle('The New Adventure')
  .execute();

console.log('Found:', results[0]);

await rag.close();
```

---

### 6.7 CLI Integration & UX

**Priority**: High

**Tasks**:
- [ ] Add `schema` command group to CLI
- [ ] Add `mutations` command group to CLI
- [ ] Interactive mode for schema modifications
- [ ] Preview mode (show what will change before applying)
- [ ] Confirmation prompts for destructive operations

**Interactive Example**:
```bash
$ ragforge schema:add-entity --interactive

? Entity name: Review
? Unique field: reviewId
? Display name field: comment
? Add searchable fields? Yes
? Field 1 name: rating
? Field 1 type: number
? Add another field? Yes
? Field 2 name: comment
? Field 2 type: string
? Add another field? No

Preview changes:
  ✓ Add Review entity to ragforge.config.yaml
  ✓ Generate queries/review.ts
  ✓ Update types.ts
  ✓ Generate examples/review-search.ts

? Apply changes? Yes

✅ Entity added successfully!
Next steps:
  1. Run: ragforge generate --config ./ragforge.config.yaml
  2. Create sample data or import existing reviews
```

---

### 6.8 Integration with Vector Search

**Priority**: Medium

**Goal**: Seamlessly integrate mutations with existing vector search capabilities

**Concept**: When creating/updating entities with vector indexes, automatically handle embeddings

**Smart Embedding Management**:

```typescript
// Option 1: Auto-generate embeddings on create
const doc = await rag.document().create({
  uuid: 'doc-123',
  title: 'New Document',
  content: 'Long text content...'
}, {
  generateEmbeddings: true  // Automatically creates embeddings for vector_indexed fields
});

// Option 2: Defer embedding generation (batch later)
const doc = await rag.document().create({
  uuid: 'doc-124',
  title: 'Another Document',
  content: 'More content...'
}, {
  generateEmbeddings: false  // Skip for now
});

// Later: batch generate embeddings
await rag.embeddings.generateBatch('Document', ['doc-124', 'doc-125']);

// Option 3: Update triggers embedding regeneration
await rag.document().update('doc-123', {
  content: 'Updated content'  // Automatically regenerates content embedding
});
```

**Features**:
- **Automatic embedding generation** on create/update (configurable per-entity)
- **Embedding invalidation** when source field changes
- **Batch embedding generation** for performance
- **Background job support** for large-scale updates
- **Embedding status tracking** (pending, generating, ready, failed)
- **Webhook integration** for async embedding generation

**Configuration** (in `ragforge.config.yaml`):
```yaml
entities:
  - name: Document
    vector_indexes:
      - name: documentContentEmbeddings
        field: embedding_content
        source_field: content
        auto_generate: true           # NEW: Auto-generate on create/update
        batch_threshold: 10           # NEW: Batch if > 10 pending
        background: true              # NEW: Use background jobs
```

**Generated Methods**:
```typescript
// Check embedding status
const status = await rag.document().getEmbeddingStatus('doc-123');
// { content: 'ready', title: 'pending' }

// Force regenerate embeddings
await rag.document().regenerateEmbeddings('doc-123', ['content']);

// Bulk operations with embedding control
await rag.document().createBatch([
  { uuid: 'd1', content: 'Text 1' },
  { uuid: 'd2', content: 'Text 2' }
], {
  generateEmbeddings: 'background'  // Generate in background job
});
```

**Background Job System** (Optional):
- Track embedding generation jobs in Neo4j
- Retry failed embeddings
- Monitor progress
- Webhook notifications when complete

---

## Phase 5: Quality Assurance

### 5.1 Documentation Review

**Tasks**:
- [ ] Spell check all documentation
- [ ] Verify all code examples work
- [ ] Test all commands shown in docs
- [ ] Ensure consistent terminology
- [ ] Add table of contents to long docs
- [ ] Cross-link related documentation

### 5.2 Examples Testing

**Tasks**:
- [ ] Create CI workflow to test examples
- [ ] Ensure all examples can be run from scratch
- [ ] Verify all generated code compiles
- [ ] Test embedding generation in examples
- [ ] Document minimum system requirements

### 5.3 User Testing

**Tasks**:
- [ ] Have external users follow examples
- [ ] Gather feedback on clarity
- [ ] Identify missing information
- [ ] Fix confusing sections
- [ ] Add FAQ based on questions

---

## Implementation Priority

### Immediate (Week 1-2)
1. ✅ Phase 1.1: Update Root README
2. ✅ Phase 2.1: Organize examples directory
3. ✅ Phase 2.2: Enhance bookstore example
4. ✅ Phase 2.5: Create examples index

### Short Term (Week 3-4)
5. ✅ Phase 1.2: Update CLI README
6. ✅ Phase 2.3: Enhance code-search example
7. ✅ Phase 2.4: Create documentation example

### Medium Term (Month 2)
8. Phase 3.3: Advanced documentation guides
9. Phase 3.1: Generate empty database feature
10. **Phase 6.1: Schema modification commands** (add-entity, add-field, add-relationship)
11. **Phase 6.2: Generate CRUD operations**
12. Phase 5: Quality assurance & testing

### Long Term (Month 3+)
13. Phase 3.2: Seed data templates
14. Phase 4: Interactive improvements
15. **Phase 6.3-6.7: Advanced mutation features** (incremental regen, migrations, etc.)

---

## Success Metrics

### Documentation Quality
- [ ] New users can start from zero to running example in < 10 minutes
- [ ] Each workflow (DB-first, YAML-first) has clear guide
- [ ] Zero questions about .env setup
- [ ] Auto-detection features are well explained

### Examples Quality
- [ ] At least 3 complete, working examples
- [ ] Each example has README with < 5 minute setup
- [ ] Examples cover different domains (e-commerce, code, docs)
- [ ] Examples demonstrate different workflows
- [ ] All examples include seed data and can run standalone

### User Experience
- [ ] `ragforge -h` immediately shows quickest path to success
- [ ] Examples are discoverable (`ragforge examples` command?)
- [ ] Consistent terminology across all docs
- [ ] Clear error messages with actionable solutions

### Mutation & Schema Evolution (Phase 6)
- [ ] Users can add entities/fields/relationships without manual YAML editing
- [ ] CRUD operations are type-safe and fully generated
- [ ] Schema evolution workflow is documented and easy to follow
- [ ] Adding a new entity auto-generates all related code (types, queries, examples)
- [ ] Generated mutations include validation and error handling
- [ ] Relationship management is intuitive (create, update, delete links)
- [ ] Batch operations are available for performance-critical workflows

---

## Notes & Considerations

### Current Strengths
- Recent CLI improvements make `ragforge init` very easy
- LLM auto-detection removes manual configuration burden
- Generated examples use real data from user's database

### Current Gaps
- No clear showcase of YAML-first workflow
- Examples are scattered/not well organized
- Missing feature: generate DB from YAML config
- No comprehensive YAML reference documentation
- **Read-only framework**: No support for creating/updating/deleting entities
- **Static schema**: No tools for evolving schema over time
- **Manual mutations**: Users must write Cypher queries manually for data changes

### Why Phase 6 (Mutations) is Critical

**Current State**: RagForge is a "read-only" RAG framework - great for search and retrieval, but incomplete for real applications.

**The Gap**: Real-world applications need to:
- Create new entities (e.g., user uploads a document)
- Update existing data (e.g., fix a typo, update metadata)
- Add relationships (e.g., link new references)
- Evolve the schema over time (e.g., add a "tags" field to documents)

**Without Phase 6**, users must:
- Write manual Cypher queries for all data modifications
- Manually update the YAML config when schema changes
- Manually regenerate code after schema changes
- Risk schema drift (code doesn't match database)
- No type safety for mutations (easy to introduce bugs)

**With Phase 6**, users get:
- Type-safe CRUD operations auto-generated from schema
- CLI tools to evolve schema incrementally
- Automatic code regeneration when schema changes
- Zero schema drift (always in sync)
- Full application lifecycle support (not just RAG queries)

**This transforms RagForge from**:
- ❌ "Search-only toolkit"
- ✅ **Complete application framework**

Phase 6 is what makes RagForge production-ready for real applications.

---

### Design Principles
1. **Minimize time to first success** - Get users to working example ASAP
2. **Show, don't tell** - Complete examples > long explanations
3. **Progressive disclosure** - Simple examples first, advanced later
4. **Real-world focus** - Examples should mirror actual use cases
5. **Self-contained** - Each example should be independently runnable
6. **Complete lifecycle** - Support both read (query) and write (mutation) operations

### Future Considerations
- **Video tutorials** - Screen recordings of each workflow
- **Interactive playground** - Web-based config builder
- **Example gallery** - Showcase community examples
- **Docker images** - Pre-built examples with data included
- **GraphQL API generation** - Auto-generate GraphQL mutations from schema
- **REST API generation** - Auto-generate REST endpoints for CRUD operations
- **Webhooks/triggers** - Execute code when entities are created/updated
- **Audit logs** - Track all mutations with timestamps and user info
- **Data validation rules** - Define constraints in YAML (min/max, regex, etc.)
- **Computed fields** - Auto-calculate fields based on other fields or relationships
- **Soft deletes** - Mark entities as deleted instead of removing them
- **Versioning** - Keep history of entity changes over time
