# test-code-rag RAG Client

Version: 1.0.0

Test project for code RAG with source adapter

Generated by RagForge ‚Äì use this reference to drive both LLM agents and manual usage of the query builders.

## Quickstart

```typescript
import { createRagClient } from './client.js';

const rag = createRagClient({
  neo4j: {
    uri: process.env.NEO4J_URI!,
    username: process.env.NEO4J_USERNAME!,
    password: process.env.NEO4J_PASSWORD!
  }
});

const results = await rag.scope()
  .semantic('search text', { topK: 20 })
  .limit(10)
  .execute();
```

> Embeddings use Google Gemini (`@google/genai`) and require `GEMINI_API_KEY` in your environment.

## ‚≠ê Custom Methods (Generated from YAML Config)

This framework has been customized with methods generated from your `ragforge.config.yaml`:

## ü§ñ LLM Reranking

The framework is pre-configured with a default LLM provider (Gemini API).
Use `.llmRerank()` to intelligently rerank results ‚Äî **no need to create a provider!**

**Example:**
```typescript
```

**When to use LLM reranking:**
- Complex queries requiring reasoning (e.g., "functions that handle errors gracefully")
- When semantic search returns too many similar results
- When you need understanding beyond keyword matching

**Tip:** Start with broad semantic search (topK: 50-100), then llmRerank to top 5-10.

## üìä Pipeline Metadata & Observability

Use `.executeWithMetadata()` to get detailed information about each pipeline operation:

**Example:**
```typescript
```

### Custom Metadata Override

Add custom metadata to any operation:

```typescript
```

### Iterative Agent Helper

```typescript
import { createIterativeAgent } from './agent.js';
import type { LLMClient } from '@luciformresearch/ragforge-runtime';

const llm: LLMClient = /* wrap your LLM */;
const agent = createIterativeAgent({
  llm,
  workDir: './tmp',
  ragClientPath: './client.js'
});

const answer = await agent.answer('How does OAuth token refresh work?');
```

_Tip_: the runtime exposes `GeminiAPIProvider.fromEnv()` to bootstrap LLM reranking with `GEMINI_API_KEY`.

## Entity Reference

### Scope

Approximate nodes: 268

Usage: `const builder = rag.scope()`

**Searchable fields**
- `source` (string)

#### Query Builder Methods

- `where(filter: ScopeFilter)`
- `whereSource(string | { contains?: string; startsWith?: string; endsWith?: string })`
- Semantic helper not generated: use `.semantic(query, { topK, vectorIndex })`
- `.limit(n)`, `.offset(n)`, `.orderBy(field, direction)`
- `.expand(relType, { depth?, direction? })` for arbitrary relationship traversal

#### Example

```typescript
const results = await rag.scope()
  .whereSource({ contains: 'keyword' })
  .semantic('search query', { topK: 25 })
  .limit(10)
  .execute();
```

## Usage Patterns

- Start broad with semantic search (topK high), then filter or rerank.
- Use relationship helpers (with..., whereConsumesScope, etc.) to explore the graph.
- Combine semantic search and relationship expansion to build rich context.
- The iterative agent uses exactly these methods; provide clear objectives.

---
Generated automatically by RagForge.